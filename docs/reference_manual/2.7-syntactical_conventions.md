## Syntactical conventionsIn the remainder of the document, and in the Syntax sections in particular, a meta-syntax is used to describe the syntax of the operators. The meta-syntax is described in this section and is **not part** of the VTL language, but has only presentation purposes.* _For denoting the type of a Variable Parameter, we refer to the â€“ **VTL types (See User Manual, Section "Objects and Types")**._* _Operator names and parameters are **case sensitive**._* _In general, some operators have infix style, others have functional style and the clauses have postfix style._

The syntax of the operators is defined by meta-expressions, which denotes the signature of an operator, that is, its **name**, the list of **the input parameters**, the possible special **keywords** and the respective **types**. For readability reasons, a meta-expression is often partitioned into concatenated sub-meta-expressions (or simply sub-expressions), as follows:```meta-expression  ::=  sub-expr1 sub-expr2 ... sub-exprN	sub-expr1 ::= sub-meta-expression ...	...	sub-exprN ::= sub-meta-expression ...
```
In this representation:* The _sub-expr1, ... sub-exprN_ are meta-variables, that is, placeholders for sub-expressions. In the text, they are in _italic_.
* The symbol ::= means "defined as" and denotes the assignment of a sub-expression to a meta-variable.
* The operator names and the special keywords that appear in the various sub-expressions are in **bold**.

Sub-expressions can be composed into the meta-expression adopting a particular restriction of **regular expression patterns** as follows:* _{optional}, {optional}?,[optional]? : alternative ways to denote an optional sub-expression_* _{one-or-more}+: a sub-expression that is repeated from 1 to many occurrences_* _{zero-or-more}*: a sub-expression that is repeated from 0 to many occurrences_* _[part1|part2|part3]: alternative sub-expressions_* _[part1|part2|part3]+: alternative sub-expressions, from 1 to many occurrences_* _[part1|part2|part3]*: alternative sub-expressions, from 0 to many occurrences_### Example**\[trim | ltrim | rtrim \] ( ds )**
```ds : dataset {identifier <IDENT> as scalar-type}+
 {measure <IDENT> as string-literal}+
 {attribute <IDENT> as scalar-type}*```
The meta-expression above synthesizes:* **trim**, **ltrim**, **rtrim**, "**(**", "**)**" are the operator names (reserved keywords);* They take s input an expression ds, which is a meta-sub-expression and defined accordingly;* the type of ds is constrained to be a Dataset with one or more Identifier Components and one or more string Measure Component. No particular constraints are introduced for attributes.* ds is the only parameter of the operators in the example and denotes a Dataset. Specifically, <IDENT> is a placeholder for any identifier (measure or attribute, in the different cases).From this template, it is possible to infer some valid instances of the operators:```
ds_1 := ltrim(ds_2)ds_1 := rtrim(ds_3)```

The two examples above are compliant with the template. In facts, **ltrim** and **rtrim** are recognized as VTL operators of the library and ds_2 and ds_3 are two Datasets. Also observe that the example implies a previous definition of ds_2 and ds_3, for example importing the Datasets from the database (as we will see, with the GET operator). The restrictions on the specific structure of the input Datasets, in terms of allowed Identifier and Measure Components, are also checked, but do not have effects on the syntax. 